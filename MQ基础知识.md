## MQ简介
MQ的全称是MessageQuery（消息队列），它既是一种‘先进先出’的基本数据结构，也是IT系统内部应用之间进行通信的一种手段。
## MQ解决什么问题？
### 1、	解耦
在一个系统中完成某项工作往往需要多个模块的配合，如果耦合调用这些模块，任何一个模块出现故障之后就会造成工作无法完成或者工作的结果是错误的。
当转变成给予消息队列得方式后，系统间调用的问题就会减少很多。此时如果某个模块发生系统故障，需要几分钟的时间来进行修复，此时系统中要处理的内存就会缓存在消息队列当中，当系统修复完成之后继续执行。用户在使用的过程中就不会感受到系统故障，系统的可用性就得到了大幅度提高。
### 2、	消峰
如果系统最多处理1000条请求，某一天同时有3000个用户发出请求，此时系统是处理不了的，就需要对同时处理的数量加上限制。如果使用消息队列得话我就就可以把这个限制取消掉掉。把同时处理的请求分散成一个时间段进行处理，有些用户就会在数秒后获得响应，比请求失败要好的多。
### 3、	分发消息
对个服务队数据感兴趣的话，只需要监听同一类消息即可。
比如：A负责产生数据，B负责处理数据，如果没有消息队列，A每次产生数据后就要调用一下B来处理数据，如果此时又来了一个C处理数据，那么A就需要修改代码。
使用消息队列后：A只负责产生数据后发送一次消息到消息队列，B要处理数据的话只需要监听一下消息。C也要处理数据，那么C也去监听消息。
### 4、	异步处理
有些服务间调用是异步的，例如A调用B，B需要花费很长时间执行，但是A需要知道B什么时候可以执行完，以前一般有两种方式，A过一段时间去调用B的查询api查询。或者A提供一个callback api，B执行完之后调用api通知A服务。这两种方式都不是好。
使用消息队列，可以很方便解决这个问题，A调用B服务后，只需要监听B处理完成的消息，当B处理完成后，会发送一条消息给MQ，MQ会将此消息转发给A服务。
这样A服务既不用循环调用B的查询api，也不用提供callback api。同样B服务也不用做这些操作。A服务还能及时的得到异步处理成功的消息。

