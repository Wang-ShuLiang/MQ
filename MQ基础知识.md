## MQ简介
MQ的全称是MessageQuery（消息队列），它既是一种‘先进先出’的基本数据结构，也是IT系统内部应用之间进行通信的一种手段。
## MQ解决什么问题？
### 1、	解耦
在一个系统中完成某项工作往往需要多个模块的配合，如果耦合调用这些模块，任何一个模块出现故障之后就会造成工作无法完成或者工作的结果是错误的。<br/>
当转变成给予消息队列得方式后，系统间调用的问题就会减少很多。此时如果某个模块发生系统故障，需要几分钟的时间来进行修复，此时系统中要处理的内存就会缓存在消息队列当中，当系统修复完成之后继续执行。用户在使用的过程中就不会感受到系统故障，系统的可用性就得到了大幅度提高。
### 2、	消峰
如果系统最多处理1000条请求，某一天同时有3000个用户发出请求，此时系统是处理不了的，就需要对同时处理的数量加上限制。<br/>
如果使用消息队列得话我就就可以把这个限制取消掉掉。把同时处理的请求分散成一个时间段进行处理，有些用户就会在数秒后获得响应，比请求失败要好的多。
### 3、	分发消息
对个服务队数据感兴趣的话，只需要监听同一类消息即可。<br/>
比如：A负责产生数据，B负责处理数据，如果没有消息队列，A每次产生数据后就要调用一下B来处理数据，如果此时又来了一个C处理数据，那么A就需要修改代码。
使用消息队列后：A只负责产生数据后发送一次消息到消息队列，B要处理数据的话只需要监听一下消息。C也要处理数据，那么C也去监听消息。
### 4、	异步处理
有些服务间调用是异步的，例如A调用B，B需要花费很长时间执行，但是A需要知道B什么时候可以执行完，以前一般有两种方式，A过一段时间去调用B的查询api查询。或者A提供一个callback api，B执行完之后调用api通知A服务。这两种方式都不是好。<br/>
使用消息队列，可以很方便解决这个问题，A调用B服务后，只需要监听B处理完成的消息，当B处理完成后，会发送一条消息给MQ，MQ会将此消息转发给A服务。
这样A服务既不用循环调用B的查询api，也不用提供callback api。同样B服务也不用做这些操作。A服务还能及时的得到异步处理成功的消息。

#### 综合以上四点，它主要用于比较耗时且不需要立即生效返回结果的操作。我们将这种操作作为一个消息放入消息队列中，处理方在任何时候都可以去获取消息并进行处理。<br/>
以用户注册为例：<br/>
用户在软件中进行注册，这个软件可能会做如下操作：<br/>
1、对用户信息进行验证，通过后保存在数据库中。2、发送邮件或者短信告知用户注册成功。3、发送给用户一个操作指南的通知。4、分析用户信息，向用户推荐内容等<br/>
在这一系列的操作中，对于用户来讲，他关心的仅仅是注册是否成功，对于其他的事情，服务端就可以吧这些操作放入消息队列当中，让消息队列异步的进行这些操作。
## 常见的MQ有哪些？它们之间有什么区别？
#### 现在比较常见的消息队列产品主要有  Kafka、ActiveMQ、RabbitMQ、ZeroMQ、RocketMQ、Apollo等。
### Kafka
 Kafka是分布式的发布—订阅消息系统。它最初由LinkedIn(领英)公司发布，使用Scala语言编写，与2010年12月份开源，成为Apache的顶级项目。
   Kafka是一个高吞吐量的、持久性的、分布式发布订阅消息系统。
   它主要用于处理活跃的数据(登录、浏览、点击、分享、喜欢等用户行为产生的数据)。
三大特点：
高吞吐量
   可以满足每秒百万级别消息的生产和消费——生产消费。
持久性
   有一套完善的消息存储机制，确保数据的高效安全的持久化——中间存储。
分布式
   基于分布式的扩展和容错机制；Kafka的数据都会复制到几台服务器上。当某一台故障失效时，生产者和消费者转而使用其它的机器——整体健壮性。
### ActiveMQ
### RabbitMQ
### ZeroMQ
### RocketMQ
### Apollo
