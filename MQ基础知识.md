## MQ简介
MQ的全称是MessageQuery（消息队列），它既是一种‘先进先出’的基本数据结构，也是IT系统内部应用之间进行通信的一种手段。
## MQ解决什么问题？
### 1、	解耦
在一个系统中完成某项工作往往需要多个模块的配合，如果耦合调用这些模块，任何一个模块出现故障之后就会造成工作无法完成或者工作的结果是错误的。<br/>
当转变成给予消息队列得方式后，系统间调用的问题就会减少很多。此时如果某个模块发生系统故障，需要几分钟的时间来进行修复，此时系统中要处理的内存就会缓存在消息队列当中，当系统修复完成之后继续执行。用户在使用的过程中就不会感受到系统故障，系统的可用性就得到了大幅度提高。
### 2、	消峰
如果系统最多处理1000条请求，某一天同时有3000个用户发出请求，此时系统是处理不了的，就需要对同时处理的数量加上限制。<br/>
如果使用消息队列得话我就就可以把这个限制取消掉掉。把同时处理的请求分散成一个时间段进行处理，有些用户就会在数秒后获得响应，比请求失败要好的多。
### 3、	分发消息
对个服务队数据感兴趣的话，只需要监听同一类消息即可。<br/>
比如：A负责产生数据，B负责处理数据，如果没有消息队列，A每次产生数据后就要调用一下B来处理数据，如果此时又来了一个C处理数据，那么A就需要修改代码。
使用消息队列后：A只负责产生数据后发送一次消息到消息队列，B要处理数据的话只需要监听一下消息。C也要处理数据，那么C也去监听消息。
### 4、	异步处理
有些服务间调用是异步的，例如A调用B，B需要花费很长时间执行，但是A需要知道B什么时候可以执行完，以前一般有两种方式，A过一段时间去调用B的查询api查询。或者A提供一个callback api，B执行完之后调用api通知A服务。这两种方式都不是好。<br/>
使用消息队列，可以很方便解决这个问题，A调用B服务后，只需要监听B处理完成的消息，当B处理完成后，会发送一条消息给MQ，MQ会将此消息转发给A服务。
这样A服务既不用循环调用B的查询api，也不用提供callback api。同样B服务也不用做这些操作。A服务还能及时的得到异步处理成功的消息。

#### 综合以上四点，它主要用于比较耗时且不需要立即生效返回结果的操作。我们将这种操作作为一个消息放入消息队列中，处理方在任何时候都可以去获取消息并进行处理。<br/>
以用户注册为例：<br/>
用户在软件中进行注册，这个软件可能会做如下操作：<br/>
1、对用户信息进行验证，通过后保存在数据库中。2、发送邮件或者短信告知用户注册成功。3、发送给用户一个操作指南的通知。4、分析用户信息，向用户推荐内容等<br/>
在这一系列的操作中，对于用户来讲，他关心的仅仅是注册是否成功，对于其他的事情，服务端就可以吧这些操作放入消息队列当中，让消息队列异步的进行这些操作。
## 常见的MQ有哪些？它们之间有什么区别？
#### 现在比较常见的消息队列产品主要有  Kafka、ActiveMQ、RabbitMQ、ZeroMQ、RocketMQ等。
### Kafka
 Kafka是分布式的发布—订阅消息系统。它最初由LinkedIn(领英)公司发布，使用Scala语言编写，与2010年12月份开源，成为Apache的顶级项目。
   Kafka是一个高吞吐量的、持久性的、分布式发布订阅消息系统。
   它主要用于处理活跃的数据(登录、浏览、点击、分享、喜欢等用户行为产生的数据)。
三大特点：
高吞吐量
   可以满足每秒百万级别消息的生产和消费——生产消费。
持久性
   有一套完善的消息存储机制，确保数据的高效安全的持久化——中间存储。
分布式
   基于分布式的扩展和容错机制；Kafka的数据都会复制到几台服务器上。当某一台故障失效时，生产者和消费者转而使用其它的机器——整体健壮性。
### ActiveMQ
Apache下的一个子项目。使用Java完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，少量代码就可以高效地实现高级应用场景。可插拔的传输协议支持，比如：in-VM, TCP, SSL, NIO, UDP, multicast, JGroups and JXTA transports。RabbitMQ、ZeroMQ、ActiveMQ均支持常用的多种语言客户端 C++、Java、.Net,、Python、 Php、 Ruby等。
### RabbitMQ
使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP,STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。同时实现了Broker架构，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队。对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持。多用于进行企业级的ESB整合。
### ZeroMQ
号称最快的消息队列系统，专门为高吞吐量/低延迟的场景开发，在金融界的应用中经常使用，偏重于实时数据通信场景。ZMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，开发成本高。因此ZeroMQ具有一个独特的非中间件的模式，更像一个socket library，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序本身就是使用ZeroMQ API完成逻辑服务的角色。但是ZeroMQ仅提供非持久性的队列，如果down机，数据将会丢失。如：Twitter的Storm中使用ZeroMQ作为数据流的传输。

ZeroMQ套接字是与传输层无关的：ZeroMQ套接字对所有传输层协议定义了统一的API接口。默认支持 进程内(inproc) ，进程间(IPC) ，多播，TCP协议，在不同的协议之间切换只要简单的改变连接字符串的前缀。可以在任何时候以最小的代价从进程间的本地通信切换到分布式下的TCP通信。ZeroMQ在背后处理连接建立，断开和重连逻辑。
### RocketMQ
阿里系下开源的一款分布式、队列模型的消息中间件，原名Metaq，3.0版本名称改为RocketMQ，是阿里参照kafka设计思想使用java实现的一套mq。同时将阿里系内部多款mq产品（Notify、metaq）进行整合，只维护核心功能，去除了所有其他运行时依赖，保证核心功能最简化，在此基础上配合阿里上述其他开源产品实现不同场景下mq的架构，目前主要多用于订单交易系统。
<table >
 <tr style="width:100%;">
 <td style="width:10%;">吞吐量</td>
  <td style="width:90%;">万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。</td>
 </tr>
  <tr style="width:100%;">
 <td style="width:10%;">可用性</td>
  <td style="width:90%;">都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
 </tr>
  <tr style="width:100%;">
 <td style="width:10%;">时效性</td>
  <td style="width:90%;">abbitMQ 基于erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。</td>
 </tr>
  <tr style="width:100%;">
 <td style="width:10%;">功能支持</td>
  <td style="width:90%;">除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td>
 </tr>
  <tr style="width:100%;">
 <td style="width:10%;">消息丢失</td>
  <td style="width:90%;">ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。</td>
 </tr>
 </table>
